Benchmarking ORM используемых при создании Android-приложений
=============================================================

Привет, Хабр! Меня зовут Артем Добровинский и я Android-разработчик в FINCH.

Однажды за утренней сигарой я копался в исходниках одной ORM для Android. Увидев там package под названием `benchmarks` был в очередной раз удивлен тем, что все замеры там выполнены с помощью `Log.d(System.currentTimeMillis())`. Обрушившееся осознание того, что что-то надо менять, заставило отставить в сторону бокал с виски и сесть за клавиатуру.

### Почему
Ситуация с пониманием того, как мерять производительность кода в Android — днище.   
Люди кидают друг другу результаты на коленке написанных принтов таймингов не понимая, что принимать это за хоть сколь корректное измерением можно только, если ты не знаешь, как работает JVM.   
Т.е., необходимо в 2019 году быть уверенным, что JVM делает всё, что ты написал в том порядке, в котором ты написал — а нет ничего более далекого от истины.   
На самом деле, несчастная виртуальная машина отбивается от миллиарда безалаберных кнопкодавов, которые пишут целые программы, ни разу не напрягшись о том, как с этим кодом будет работать процессор. Этот процесс длится уже не первый год и , в рукаве у неё миллион хитрейших оптимизаций, которые (если их игнорировать) превратят любое измерение производительности программы в потерю времени. 

Да, при любом обсуждении бенчмаркинга с коллегами всегда найдется кто-то, кто вынув изо рта мундштук ароматного и крепкого кальяна скажет, что «А меряй-не меряй, в проде всё в других условиях будет работать». И будет прав.   
Зачем тогда всё это надо?   
Во-первых (и это главная причина), нет лучшей почвы для холивара. Услышал мнение «А вот %FRAMEWORK% лучше», и сразу швырнул в центр комнаты распечатку со свежими бенчмарками — а то с полудня тихо, как в библиотеке.   
Во-вторых, если создать для измерений всех кейсов максимально схожие и идеальные условия — можно получить полезную информацию. Чтобы их создать надо знать, как это делать и на что обращать внимание, но возможно — создать практически идеальную ситуацию и получить значимый результат. 

Если нужны доводы по поводу того, пользоваться ли для замера производительности сторонними фреймворками — всегда можно почитать [Алексея Шипилёва](https://shipilev.net/blog/2014/nanotrusting-nanotime/#_timers) и поразиться глубине проблемы. В статье по ссылке всё есть: и зачем нужен warmup перед проведением бенчмарка, почему `System.currentTimeMillis()` нельзя доверять вообще при подсчете прошедшего (elapsed) времени, и шутки за 300. Отличное чтиво. 

##### Почему я могу об этом рассказывать?   
Дело в том, что я всесторонне развитый разработчик: я не только владею Android SDK так, будто это мой pet-project, но еще где-то месяц писал код для бекенда.   
Когда я принес лиду свой микросервис на ревью, и там в `README` не было бенчмаркинга — он смотрел на меня с непониманием.   
Я запомнил это и больше никогда не повторял этой ошибки. Потому-что ушел через неделю.

Поехали.

### Что измеряем
В рамках кейса по бенчмаркингу баз данных под Android я решил померить скорость иницализации плюс записи/чтения для Paper, Hawk, Realm и Room.   
Да, я меряю в одном тесте NoSQL и реляционную БД — какой следующий вопрос?

### Чем измеряем
Казалось бы, если речь о JVM, то выбор очевиден — есть [покрытый славой](https://mvnrepository.com/tags/benchmark), [доведенный до совершенства](https://groups.google.com/forum/#!topic/mechanical-sympathy/m4opvy4xq3U) и безупречный [JMH](). Но нет, на нём не заведyтся инструментационные тесты для Android.   
Есть [JUnit4Benchmarks]() — та же ситуация.   
Следом за ними идет [Calipher]() от Google — с тем же результатом.    
Есть форк Calipher под называнием [Spanner]() — который как много лет задеперкейчен и призывает пользоваться [androidx-benchmarking]().   
На androidx-benchmarking и остановим внимание.

Как и всё, что было добавлено в Jetpack, а не переосмыслено при переносе из Support Library, androidx-benchmarking выглядит и ведёт себя так, будто был написан за неделю-полторы в качестве тестового задания, и больше к нему никто никогда не притронется.   
Но за неимением лучшего, можно работать и с ним. Он сохранит хотя бы от [очевидных ошибок](), плюс поможет с разогревом. Тоже хлеб.

### Подключение библиотеки в проект
По подключению andoridx-benchmark в проект есть [отличная инструкция](https://developer.android.com/studio/profile/benchmark.md). Очень советую не полениться и подключить отдельный модуль для производства измерений. 

### фжлвыоафыжвлао
Все наши бенчмарки будут исполнятся в следующем порядке:
1. Сначала мы инициируем базу данных в теле теста.
2. Затем в блоке `benchmarkRule.scope.runWithTimingDisabled` генерим данные, которые скормим базе данных.
3. Замеряем производительность инициализации БД в отдельном методе. Для замера оборачиваем логику в замыкание `benchmarkRule.measureRepeated`.
4. Схожий блок подавления таймина с логикой очищения БД вставляем во второй метод; убеждаемся, что база данных пуста перед записью. 
5. Далее следует логика записи и чтения. Обязательно ицициализируем переменную с результатом чтения, чтобы JVM не удалил эту логику из исполнения, как неиспользуемую. 
6. Мы великолепны!

Код можно посмотреть [здесь](). Если лениво ходить, функция с замером для PaperDb выглядит так:
```kotlin
@Test
fun paperdbInsertReadTest() = benchmarkRule.measureRepeated {
    benchmarkRule.scope.runWithTimingDisabled {
        Paper.book().destroy()
        if (Paper.book().allKeys.isNotEmpty()) throw RuntimeException()
    }
    repository.store(persons, { list -> Paper.book().write(KEY_CONTACTS, list) })
    val persons = repository.read { Paper.book().read<List<Person>>(KEY_CONTACTS, emptyList()) }
}
```

#### Результаты

todo

### Заключение

Нет ни одной причины не измерять производительность своего кода.   
Есть все причины привлекать для этого дела сторонние фреймворки (или написать свой).    
У всех всё по-clean'у, у всех модуль с бизнес-логикой является java-модулем — подключить рядом модуль c jmh и проверять код на наличие бутылочных горлышек — работы на день. А пользы — на много лет вперед.

Happy coding!